<!--- COMPONENT ---><cfcomponent displayname="SpeakerFeedbackGateway" output="false" hint="I am the SpeakerFeedbackGateway class."><!--- Pseudo-constructor ---><cfset variables.instance = {	datasource = ''} /><cffunction name="init" access="public" output="false" returntype="any" hint="I am the constructor method of the SpeakerFeedbackGateway class.">  <cfargument name="datasource" type="any" required="true" hint="I am the Datasource bean." />  <!--- Set the initial values of the Bean --->  <cfscript>	variables.instance.datasource = arguments.datasource;  </cfscript>  <cfreturn this></cffunction><!--- PUBLIC METHODS ---><!--- NO FILTER - GET ALL RECORDS ---><cffunction name="getAllSpeakerFeedback" access="public" output="false" returntype="query" hint="I return a query of all records in the speaker_feedback table in the database.">    <cfset var thisFilter = {	bogus = 'bogus'    } />  <cfreturn filterAllSpeakerFeedback(thisFilter) /></cffunction><!--- FILTER ---><cffunction name="filter" access="public" output="false" returntype="any" hint="I run a query of all records within the database table.">  <cfargument name="speakerId" type="any" required="false" default="" hint="I am the speakerId numeric to return records for." />  <cfargument name="speakerRequestId" type="any" required="false" default="" hint="I am the speakerRequestId numeric to return records for." />  <cfargument name="punctuality" type="any" required="false" default="" hint="I am the punctuality boolean to return records for." />  <cfargument name="preparedness" type="any" required="false" default="" hint="I am the preparedness boolean to return records for." />  <cfargument name="knowledge" type="any" required="false" default="" hint="I am the knowledge boolean to return records for." />  <cfargument name="quality" type="any" required="false" default="" hint="I am the quality boolean to return records for." />  <cfargument name="satisfaction" type="any" required="false" default="" hint="I am the satisfaction boolean to return records for." />  <cfargument name="recommend" type="any" required="false" default="" hint="I am the recommend boolean to return records for." />  <cfargument name="review" type="any" required="false" default="" hint="I am the review string to return records for." />  <cfargument name="orderBy" type="any" required="false" default="" hint="I am the column (and optional ordinal ASC or DESC) that records should be ordered by." />  <cfargument name="cache" type="any" required="false" default="false" hint="I am a flag to determine if this query should be cached." />  <cfargument name="cacheTime" type="any" required="false" default="#CreateTimeSpan(0,1,0,0)#" hint="I am timespan to cache this query (Use CreateTimeSpan() or use the default cache time of one hour by not passing this variable." />    <cfset var thisFilter = StructNew() />    <cfif IsDefined('ARGUMENTS.speakerId') AND ARGUMENTS.speakerId NEQ "">		<cfset thisFilter.speakerId = ARGUMENTS.speakerId />    </cfif>    <cfif IsDefined('ARGUMENTS.speakerRequestId') AND ARGUMENTS.speakerRequestId NEQ "">		<cfset thisFilter.speakerRequestId = ARGUMENTS.speakerRequestId />    </cfif>    <cfif IsDefined('ARGUMENTS.punctuality') AND ARGUMENTS.punctuality NEQ "">		<cfset thisFilter.punctuality = ARGUMENTS.punctuality />    </cfif>    <cfif IsDefined('ARGUMENTS.preparedness') AND ARGUMENTS.preparedness NEQ "">		<cfset thisFilter.preparedness = ARGUMENTS.preparedness />    </cfif>    <cfif IsDefined('ARGUMENTS.knowledge') AND ARGUMENTS.knowledge NEQ "">		<cfset thisFilter.knowledge = ARGUMENTS.knowledge />    </cfif>    <cfif IsDefined('ARGUMENTS.quality') AND ARGUMENTS.quality NEQ "">		<cfset thisFilter.quality = ARGUMENTS.quality />    </cfif>    <cfif IsDefined('ARGUMENTS.satisfaction') AND ARGUMENTS.satisfaction NEQ "">		<cfset thisFilter.satisfaction = ARGUMENTS.satisfaction />    </cfif>    <cfif IsDefined('ARGUMENTS.recommend') AND ARGUMENTS.recommend NEQ "">		<cfset thisFilter.recommend = ARGUMENTS.recommend />    </cfif>    <cfif IsDefined('ARGUMENTS.review') AND ARGUMENTS.review NEQ "">		<cfset thisFilter.review = ARGUMENTS.review />    </cfif>    <cfif IsDefined('ARGUMENTS.orderBy') AND ARGUMENTS.orderBy NEQ "">		<cfset thisFilter.order_by = ARGUMENTS.orderBy />    </cfif>    <cfif IsDefined('ARGUMENTS.cache') AND ARGUMENTS.cache NEQ "">		<cfset thisFilter.cache = ARGUMENTS.cache />    </cfif>    <cfif IsDefined('ARGUMENTS.cacheTime') AND ARGUMENTS.cacheTime NEQ "">		<cfset thisFilter.cacheTime = ARGUMENTS.cacheTime />    </cfif>  <cfif NOT structIsEmpty(thisFilter) AND structKeyExists(thisFilter, 'cache') AND thisFilter.cache>    <cfreturn cacheAllSpeakerFeedback(thisFilter) />  <cfelse>    <cfreturn filterAllSpeakerFeedback(thisFilter) />  </cfif></cffunction><!--- PRIVATE METHODS ---><!--- QUERY - CACHE ALL ---><cffunction name="cacheAllSpeakerFeedback" access="private" output="false" returntype="any" hint="I run a query and will return all speakerFeedback records. If a filter has been applied, I will refine results based on the filter.">  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />	<cfset var cachedQueryName = Hash(serializeJSON(ARGUMENTS.filter),'MD5') />	<cfquery name="#cachedQueryName#" datasource="#variables.instance.datasource.getDSN()#" username="#variables.instance.datasource.getUsername()#" password="#variables.instance.datasource.getPassword()#" cachedwithin="#ARGUMENTS.filter.cacheTime#">		SELECT speakerFeedbackId, speakerId, speakerRequestId, punctuality, preparedness, knowledge, quality, satisfaction, recommend, review		FROM speaker_feedback		WHERE 1 = 1  <cfif NOT structIsEmpty(ARGUMENTS.filter)>    <!--- filter is applied --->    <cfif structKeyExists(ARGUMENTS.filter, 'speakerId')>		AND speakerId = <cfqueryparam value="#ARGUMENTS.filter.speakerId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'speakerRequestId')>		AND speakerRequestId = <cfqueryparam value="#ARGUMENTS.filter.speakerRequestId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'punctuality')>		AND punctuality = <cfqueryparam value="#ARGUMENTS.filter.punctuality#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'preparedness')>		AND preparedness = <cfqueryparam value="#ARGUMENTS.filter.preparedness#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'knowledge')>		AND knowledge = <cfqueryparam value="#ARGUMENTS.filter.knowledge#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'quality')>		AND quality = <cfqueryparam value="#ARGUMENTS.filter.quality#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'satisfaction')>		AND satisfaction = <cfqueryparam value="#ARGUMENTS.filter.satisfaction#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'recommend')>		AND recommend = <cfqueryparam value="#ARGUMENTS.filter.recommend#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'review')>		AND review = <cfqueryparam value="#ARGUMENTS.filter.review#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>	ORDER BY #ARGUMENTS.filter.order_by#    </cfif>  </cfif>  </cfquery>  <cfreturn variables[cachedQueryName] /></cffunction><!--- QUERY - FILTER ALL ---><cffunction name="filterAllSpeakerFeedback" access="private" output="false" returntype="any" hint="I run a query and will return all speakerFeedback records. If a filter has been applied, I will refine results based on the filter.">  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />  <cfset var qGetSpeakerFeedback = '' />  <cfquery name="qGetSpeakerFeedback" datasource="#variables.instance.datasource.getDSN()#" username="#variables.instance.datasource.getUsername()#" password="#variables.instance.datasource.getPassword()#">		SELECT speakerFeedbackId, speakerId, speakerRequestId, punctuality, preparedness, knowledge, quality, satisfaction, recommend, review		FROM speaker_feedback		WHERE 1 = 1  <cfif NOT structIsEmpty(ARGUMENTS.filter)>    <!--- filter is applied --->    <cfif structKeyExists(ARGUMENTS.filter, 'speakerId')>		AND speakerId = <cfqueryparam value="#ARGUMENTS.filter.speakerId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'speakerRequestId')>		AND speakerRequestId = <cfqueryparam value="#ARGUMENTS.filter.speakerRequestId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'punctuality')>		AND punctuality = <cfqueryparam value="#ARGUMENTS.filter.punctuality#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'preparedness')>		AND preparedness = <cfqueryparam value="#ARGUMENTS.filter.preparedness#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'knowledge')>		AND knowledge = <cfqueryparam value="#ARGUMENTS.filter.knowledge#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'quality')>		AND quality = <cfqueryparam value="#ARGUMENTS.filter.quality#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'satisfaction')>		AND satisfaction = <cfqueryparam value="#ARGUMENTS.filter.satisfaction#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'recommend')>		AND recommend = <cfqueryparam value="#ARGUMENTS.filter.recommend#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'review')>		AND review = <cfqueryparam value="#ARGUMENTS.filter.review#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>	ORDER BY #ARGUMENTS.filter.order_by#    </cfif>  </cfif>  </cfquery>  <cfreturn qGetSpeakerFeedback />  </cffunction></cfcomponent>