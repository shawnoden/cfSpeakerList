<!--- COMPONENT ---><cfcomponent displayname="EventFeedbackGateway" output="false" hint="I am the EventFeedbackGateway class."><!--- Pseudo-constructor ---><cfset variables.instance = {	datasource = ''} /><cffunction name="init" access="public" output="false" returntype="any" hint="I am the constructor method of the EventFeedbackGateway class.">  <cfargument name="datasource" type="any" required="true" hint="I am the Datasource bean." />  <!--- Set the initial values of the Bean --->  <cfscript>	variables.instance.datasource = arguments.datasource;  </cfscript>  <cfreturn this></cffunction><!--- PUBLIC METHODS ---><!--- NO FILTER - GET ALL RECORDS ---><cffunction name="getAllEventFeedback" access="public" output="false" returntype="query" hint="I return a query of all records in the event_feedback table in the database.">    <cfset var thisFilter = {	bogus = 'bogus'    } />  <cfreturn filterAllEventFeedback(thisFilter) /></cffunction><!--- FILTER ---><cffunction name="filter" access="public" output="false" returntype="any" hint="I run a query of all records within the database table.">  <cfargument name="speakerId" type="any" required="false" default="" hint="I am the speakerId numeric to return records for." />  <cfargument name="speakerRequestId" type="any" required="false" default="" hint="I am the speakerRequestId numeric to return records for." />  <cfargument name="venueQuality" type="any" required="false" default="" hint="I am the venueQuality boolean to return records for." />  <cfargument name="difficulty" type="any" required="false" default="" hint="I am the difficulty boolean to return records for." />  <cfargument name="avQuality" type="any" required="false" default="" hint="I am the avQuality boolean to return records for." />  <cfargument name="applicability" type="any" required="false" default="" hint="I am the applicability boolean to return records for." />  <cfargument name="recommend" type="any" required="false" default="" hint="I am the recommend boolean to return records for." />  <cfargument name="review" type="any" required="false" default="" hint="I am the review string to return records for." />  <cfargument name="orderBy" type="any" required="false" default="" hint="I am the column (and optional ordinal ASC or DESC) that records should be ordered by." />  <cfargument name="cache" type="any" required="false" default="false" hint="I am a flag to determine if this query should be cached." />  <cfargument name="cacheTime" type="any" required="false" default="#CreateTimeSpan(0,1,0,0)#" hint="I am timespan to cache this query (Use CreateTimeSpan() or use the default cache time of one hour by not passing this variable." />    <cfset var thisFilter = StructNew() />    <cfif IsDefined('ARGUMENTS.speakerId') AND ARGUMENTS.speakerId NEQ "">		<cfset thisFilter.speakerId = ARGUMENTS.speakerId />    </cfif>    <cfif IsDefined('ARGUMENTS.speakerRequestId') AND ARGUMENTS.speakerRequestId NEQ "">		<cfset thisFilter.speakerRequestId = ARGUMENTS.speakerRequestId />    </cfif>    <cfif IsDefined('ARGUMENTS.venueQuality') AND ARGUMENTS.venueQuality NEQ "">		<cfset thisFilter.venueQuality = ARGUMENTS.venueQuality />    </cfif>    <cfif IsDefined('ARGUMENTS.difficulty') AND ARGUMENTS.difficulty NEQ "">		<cfset thisFilter.difficulty = ARGUMENTS.difficulty />    </cfif>    <cfif IsDefined('ARGUMENTS.avQuality') AND ARGUMENTS.avQuality NEQ "">		<cfset thisFilter.avQuality = ARGUMENTS.avQuality />    </cfif>    <cfif IsDefined('ARGUMENTS.applicability') AND ARGUMENTS.applicability NEQ "">		<cfset thisFilter.applicability = ARGUMENTS.applicability />    </cfif>    <cfif IsDefined('ARGUMENTS.recommend') AND ARGUMENTS.recommend NEQ "">		<cfset thisFilter.recommend = ARGUMENTS.recommend />    </cfif>    <cfif IsDefined('ARGUMENTS.review') AND ARGUMENTS.review NEQ "">		<cfset thisFilter.review = ARGUMENTS.review />    </cfif>    <cfif IsDefined('ARGUMENTS.orderBy') AND ARGUMENTS.orderBy NEQ "">		<cfset thisFilter.order_by = ARGUMENTS.orderBy />    </cfif>    <cfif IsDefined('ARGUMENTS.cache') AND ARGUMENTS.cache NEQ "">		<cfset thisFilter.cache = ARGUMENTS.cache />    </cfif>    <cfif IsDefined('ARGUMENTS.cacheTime') AND ARGUMENTS.cacheTime NEQ "">		<cfset thisFilter.cacheTime = ARGUMENTS.cacheTime />    </cfif>  <cfif NOT structIsEmpty(thisFilter) AND structKeyExists(thisFilter, 'cache') AND thisFilter.cache>    <cfreturn cacheAllEventFeedback(thisFilter) />  <cfelse>    <cfreturn filterAllEventFeedback(thisFilter) />  </cfif></cffunction><!--- PRIVATE METHODS ---><!--- QUERY - CACHE ALL ---><cffunction name="cacheAllEventFeedback" access="private" output="false" returntype="any" hint="I run a query and will return all eventFeedback records. If a filter has been applied, I will refine results based on the filter.">  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />	<cfset var cachedQueryName = Hash(SerializeJSON(ARGUMENTS.filter),'MD5') />	<cfquery name="#cachedQueryName#" datasource="#variables.instance.datasource.getDSN()#" username="#variables.instance.datasource.getUsername()#" password="#variables.instance.datasource.getPassword()#" cachedwithin="#ARGUMENTS.filter.cacheTime#">		SELECT eventFeedbackId, speakerId, speakerRequestId, venueQuality, difficulty, avQuality, applicability, recommend, review		FROM event_feedback		WHERE 1 = 1  <cfif NOT structIsEmpty(ARGUMENTS.filter)>    <!--- filter is applied --->    <cfif structKeyExists(ARGUMENTS.filter, 'speakerId')>		AND speakerId = <cfqueryparam value="#ARGUMENTS.filter.speakerId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'speakerRequestId')>		AND speakerRequestId = <cfqueryparam value="#ARGUMENTS.filter.speakerRequestId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'venueQuality')>		AND venueQuality = <cfqueryparam value="#ARGUMENTS.filter.venueQuality#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'difficulty')>		AND difficulty = <cfqueryparam value="#ARGUMENTS.filter.difficulty#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'avQuality')>		AND avQuality = <cfqueryparam value="#ARGUMENTS.filter.avQuality#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'applicability')>		AND applicability = <cfqueryparam value="#ARGUMENTS.filter.applicability#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'recommend')>		AND recommend = <cfqueryparam value="#ARGUMENTS.filter.recommend#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'review')>		AND review = <cfqueryparam value="#ARGUMENTS.filter.review#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>	ORDER BY #ARGUMENTS.filter.order_by#    </cfif>  </cfif>  </cfquery>  <cfreturn variables[cachedQueryName] /></cffunction><!--- QUERY - FILTER ALL ---><cffunction name="filterAllEventFeedback" access="private" output="false" returntype="any" hint="I run a query and will return all eventFeedback records. If a filter has been applied, I will refine results based on the filter.">  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />  <cfset var qGetEventFeedback = '' />  <cfquery name="qGetEventFeedback" datasource="#variables.instance.datasource.getDSN()#" username="#variables.instance.datasource.getUsername()#" password="#variables.instance.datasource.getPassword()#">		SELECT eventFeedbackId, speakerId, speakerRequestId, venueQuality, difficulty, avQuality, applicability, recommend, review		FROM event_feedback		WHERE 1 = 1  <cfif NOT structIsEmpty(ARGUMENTS.filter)>    <!--- filter is applied --->    <cfif structKeyExists(ARGUMENTS.filter, 'speakerId')>		AND speakerId = <cfqueryparam value="#ARGUMENTS.filter.speakerId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'speakerRequestId')>		AND speakerRequestId = <cfqueryparam value="#ARGUMENTS.filter.speakerRequestId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'venueQuality')>		AND venueQuality = <cfqueryparam value="#ARGUMENTS.filter.venueQuality#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'difficulty')>		AND difficulty = <cfqueryparam value="#ARGUMENTS.filter.difficulty#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'avQuality')>		AND avQuality = <cfqueryparam value="#ARGUMENTS.filter.avQuality#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'applicability')>		AND applicability = <cfqueryparam value="#ARGUMENTS.filter.applicability#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'recommend')>		AND recommend = <cfqueryparam value="#ARGUMENTS.filter.recommend#" cfsqltype="cf_sql_tinyint" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'review')>		AND review = <cfqueryparam value="#ARGUMENTS.filter.review#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>	ORDER BY #ARGUMENTS.filter.order_by#    </cfif>  </cfif>  </cfquery>  <cfreturn qGetEventFeedback />  </cffunction></cfcomponent>