<!--- COMPONENT ---><cfcomponent displayname="SpeakerRequestGateway" output="false" hint="I am the SpeakerRequestGateway class."><!--- Pseudo-constructor ---><cfset variables.instance = {	datasource = ''} /><cffunction name="init" access="public" output="false" returntype="any" hint="I am the constructor method of the SpeakerRequestGateway class.">  <cfargument name="datasource" type="any" required="true" hint="I am the Datasource bean." />  <!--- Set the initial values of the Bean --->  <cfscript>	variables.instance.datasource = arguments.datasource;  </cfscript>  <cfreturn this></cffunction><!--- PUBLIC METHODS ---><!--- NO FILTER - GET ALL RECORDS ---><cffunction name="getAllSpeakerRequests" access="public" output="false" returntype="query" hint="I return a query of all records in the speaker_requests table in the database.">    <cfset var thisFilter = {	bogus = 'bogus'    } />  <cfreturn filterAllSpeakerRequests(thisFilter) /></cffunction><!--- FILTER ---><cffunction name="filter" access="public" output="false" returntype="any" hint="I run a query of all records within the database table.">  <cfargument name="speakerRequestId" type="any" required="false" default="" hint="I am the speakerRequestId numeric to return records for." />  <cfargument name="speakerId" type="any" required="false" default="" hint="I am the speakerId numeric to return records for." />  <cfargument name="organization" type="any" required="false" default="" hint="I am the organization string to return records for." />  <cfargument name="venue" type="any" required="false" default="" hint="I am the venue string to return records for." />  <cfargument name="eventDate" type="any" required="false" default="" hint="I am the eventDate date to return records for." />  <cfargument name="eventDateStart" type="any" required="false" default="" hint="I am the eventDateStart date to return records for." />  <cfargument name="eventDateEnd" type="any" required="false" default="" hint="I am the eventDateEnd date to return records for." />  <cfargument name="eventTime" type="any" required="false" default="" hint="I am the eventTime string to return records for." />  <cfargument name="attendees" type="any" required="false" default="" hint="I am the attendees numeric to return records for." />  <cfargument name="topic" type="any" required="false" default="" hint="I am the topic string to return records for." />  <cfargument name="isAccepted" type="any" required="false" default="" hint="I am the isAccepted boolean to return records for." />  <cfargument name="isCompleted" type="any" required="false" default="" hint="I am the isCompleted boolean to return records for." />  <cfargument name="isActive" type="any" required="false" default="" hint="I am the isActive boolean to return records for." />  <cfargument name="orderBy" type="any" required="false" default="" hint="I am the column (and optional ordinal ASC or DESC) that records should be ordered by." />  <cfargument name="cache" type="any" required="false" default="false" hint="I am a flag to determine if this query should be cached." />  <cfargument name="cacheTime" type="any" required="false" default="#CreateTimeSpan(0,1,0,0)#" hint="I am timespan to cache this query (Use CreateTimeSpan() or use the default cache time of one hour by not passing this variable." />    <cfset var thisFilter = StructNew() />    <cfif IsDefined('ARGUMENTS.speakerRequestId') AND ARGUMENTS.speakerRequestId NEQ "">		<cfset thisFilter.speakerRequestId = ARGUMENTS.speakerRequestId />    </cfif>    <cfif IsDefined('ARGUMENTS.speakerId') AND ARGUMENTS.speakerId NEQ "">		<cfset thisFilter.speakerId = ARGUMENTS.speakerId />    </cfif>    <cfif IsDefined('ARGUMENTS.organization') AND ARGUMENTS.organization NEQ "">		<cfset thisFilter.organization = ARGUMENTS.organization />    </cfif>    <cfif IsDefined('ARGUMENTS.venue') AND ARGUMENTS.venue NEQ "">		<cfset thisFilter.venue = ARGUMENTS.venue />    </cfif>    <cfif IsDefined('ARGUMENTS.eventDate') AND ARGUMENTS.eventDate NEQ "">		<cfset thisFilter.eventDate = ARGUMENTS.eventDate />    </cfif>    <cfif IsDefined('ARGUMENTS.eventDateStart') AND ARGUMENTS.eventDateStart NEQ "">		<cfset thisFilter.eventDateStart = ARGUMENTS.eventDateStart />    </cfif>    <cfif IsDefined('ARGUMENTS.eventDateEnd') AND ARGUMENTS.eventDateEnd NEQ "">		<cfset thisFilter.eventDateEnd = ARGUMENTS.eventDateEnd />    </cfif>    <cfif IsDefined('ARGUMENTS.eventTime') AND ARGUMENTS.eventTime NEQ "">		<cfset thisFilter.eventTime = ARGUMENTS.eventTime />    </cfif>    <cfif IsDefined('ARGUMENTS.attendees') AND ARGUMENTS.attendees NEQ "">		<cfset thisFilter.attendees = ARGUMENTS.attendees />    </cfif>    <cfif IsDefined('ARGUMENTS.topic') AND ARGUMENTS.topic NEQ "">		<cfset thisFilter.topic = ARGUMENTS.topic />    </cfif>    <cfif IsDefined('ARGUMENTS.isAccepted') AND ARGUMENTS.isAccepted NEQ "">		<cfset thisFilter.isAccepted = ARGUMENTS.isAccepted />    </cfif>    <cfif IsDefined('ARGUMENTS.isCompleted') AND ARGUMENTS.isCompleted NEQ "">		<cfset thisFilter.isCompleted = ARGUMENTS.isCompleted />    </cfif>    <cfif IsDefined('ARGUMENTS.isActive') AND ARGUMENTS.isActive NEQ "">		<cfset thisFilter.isActive = ARGUMENTS.isActive />    </cfif>    <cfif IsDefined('ARGUMENTS.orderBy') AND ARGUMENTS.orderBy NEQ "">		<cfset thisFilter.order_by = ARGUMENTS.orderBy />    </cfif>    <cfif IsDefined('ARGUMENTS.cache') AND ARGUMENTS.cache NEQ "">		<cfset thisFilter.cache = ARGUMENTS.cache />    </cfif>    <cfif IsDefined('ARGUMENTS.cacheTime') AND ARGUMENTS.cacheTime NEQ "">		<cfset thisFilter.cacheTime = ARGUMENTS.cacheTime />    </cfif>  <cfif NOT structIsEmpty(thisFilter) AND structKeyExists(thisFilter, 'cache') AND thisFilter.cache>    <cfreturn cacheAllSpeakerRequests(thisFilter) />  <cfelse>    <cfreturn filterAllSpeakerRequests(thisFilter) />  </cfif></cffunction><!--- PRIVATE METHODS ---><!--- QUERY - CACHE ALL ---><cffunction name="cacheAllSpeakerRequests" access="private" output="false" returntype="any" hint="I run a query and will return all speakerRequests records. If a filter has been applied, I will refine results based on the filter.">  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />	<cfset var cachedQueryName = Hash(serializeJSON(ARGUMENTS.filter),'MD5') />	<cfquery name="#cachedQueryName#" datasource="#variables.instance.datasource.getDSN()#" username="#variables.instance.datasource.getUsername()#" password="#variables.instance.datasource.getPassword()#" cachedwithin="#ARGUMENTS.filter.cacheTime#">		SELECT speakerRequestId, speakerId, requestedBy, organization, email, eventName, venue, eventDate, eventTime, attendees, topic, isAccepted, isCompleted, isActive		FROM speaker_requests		WHERE 1 = 1  <cfif NOT structIsEmpty(ARGUMENTS.filter)>    <!--- filter is applied --->    <cfif structKeyExists(ARGUMENTS.filter, 'speakerRequestId')>		AND speakerRequestId = <cfqueryparam value="#ARGUMENTS.filter.speakerRequestId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'speakerId')>		AND speakerId = <cfqueryparam value="#ARGUMENTS.filter.speakerId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'organization')>		AND organization = <cfqueryparam value="#ARGUMENTS.filter.organization#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'venue')>		AND venue = <cfqueryparam value="#ARGUMENTS.filter.venue#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'eventDate')>		AND eventDate = <cfqueryparam value="#ARGUMENTS.filter.eventDate#" cfsqltype="cf_sql_timestamp" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'eventDateStart')>		AND eventDate >= <cfqueryparam value="#ARGUMENTS.filter.eventDateStart#" cfsqltype="cf_sql_timestamp" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'eventDateEnd')>		AND eventDate <= <cfqueryparam value="#ARGUMENTS.filter.eventDateEnd#" cfsqltype="cf_sql_timestamp" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'eventTime')>		AND eventTime = <cfqueryparam value="#ARGUMENTS.filter.eventTime#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'attendees')>		AND attendees = <cfqueryparam value="#ARGUMENTS.filter.attendees#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'topic')>		AND topic = <cfqueryparam value="#ARGUMENTS.filter.topic#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'isAccepted')>		AND isAccepted = <cfqueryparam value="#ARGUMENTS.filter.isAccepted#" cfsqltype="cf_sql_bit" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'isCompleted')>		AND isCompleted = <cfqueryparam value="#ARGUMENTS.filter.isCompleted#" cfsqltype="cf_sql_bit" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'isActive')>		AND isActive = <cfqueryparam value="#ARGUMENTS.filter.isActive#" cfsqltype="cf_sql_bit" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>	ORDER BY #ARGUMENTS.filter.order_by#    </cfif>  </cfif>  </cfquery>  <cfreturn variables[cachedQueryName] /></cffunction><!--- QUERY - FILTER ALL ---><cffunction name="filterAllSpeakerRequests" access="private" output="false" returntype="any" hint="I run a query and will return all speakerRequests records. If a filter has been applied, I will refine results based on the filter.">  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />  <cfset var qGetSpeakerRequests = '' />  <cfquery name="qGetSpeakerRequests" datasource="#variables.instance.datasource.getDSN()#" username="#variables.instance.datasource.getUsername()#" password="#variables.instance.datasource.getPassword()#">		SELECT speakerRequestId, speakerId, requestedBy, organization, email, eventName, venue, eventDate, eventTime, attendees, topic, isAccepted, isCompleted, isActive		FROM speaker_requests		WHERE 1 = 1  <cfif NOT structIsEmpty(ARGUMENTS.filter)>    <!--- filter is applied --->    <cfif structKeyExists(ARGUMENTS.filter, 'speakerRequestId')>		AND speakerRequestId = <cfqueryparam value="#ARGUMENTS.filter.speakerRequestId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'speakerId')>		AND speakerId = <cfqueryparam value="#ARGUMENTS.filter.speakerId#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'organization')>		AND organization = <cfqueryparam value="#ARGUMENTS.filter.organization#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'venue')>		AND venue = <cfqueryparam value="#ARGUMENTS.filter.venue#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'eventDate')>		AND eventDate = <cfqueryparam value="#ARGUMENTS.filter.eventDate#" cfsqltype="cf_sql_timestamp" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'eventDateStart')>		AND eventDate >= <cfqueryparam value="#ARGUMENTS.filter.eventDateStart#" cfsqltype="cf_sql_timestamp" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'eventDateEnd')>		AND eventDate <= <cfqueryparam value="#ARGUMENTS.filter.eventDateEnd#" cfsqltype="cf_sql_timestamp" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'eventTime')>		AND eventTime = <cfqueryparam value="#ARGUMENTS.filter.eventTime#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'attendees')>		AND attendees = <cfqueryparam value="#ARGUMENTS.filter.attendees#" cfsqltype="cf_sql_integer" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'topic')>		AND topic = <cfqueryparam value="#ARGUMENTS.filter.topic#" cfsqltype="cf_sql_varchar" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'isAccepted')>		AND isAccepted = <cfqueryparam value="#ARGUMENTS.filter.isAccepted#" cfsqltype="cf_sql_bit" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'isCompleted')>		AND isCompleted = <cfqueryparam value="#ARGUMENTS.filter.isCompleted#" cfsqltype="cf_sql_bit" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'isActive')>		AND isActive = <cfqueryparam value="#ARGUMENTS.filter.isActive#" cfsqltype="cf_sql_bit" />    </cfif>    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>	ORDER BY #ARGUMENTS.filter.order_by#    </cfif>  </cfif>  </cfquery>  <cfreturn qGetSpeakerRequests />  </cffunction></cfcomponent>